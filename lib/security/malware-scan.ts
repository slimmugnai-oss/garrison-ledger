/**
 * MALWARE SCANNING UTILITY
 * 
 * Integrates with VirusTotal API to scan uploaded files for viruses/malware.
 * 
 * Setup:
 * 1. Get free API key: https://www.virustotal.com/gui/join-us
 * 2. Add to Vercel: VIRUSTOTAL_API_KEY=your_key_here
 * 
 * Free Tier: 500 requests/day (sufficient for typical usage)
 * 
 * Usage:
 * ```typescript
 * import { scanFile } from '@/lib/security/malware-scan';
 * 
 * const scanResult = await scanFile(fileBuffer, fileName);
 * if (!scanResult.safe) {
 *   throw Errors.invalidInput('File failed security scan');
 * }
 * ```
 */

import { logger } from '@/lib/logger';

export interface ScanResult {
  safe: boolean;
  scanId: string;
  timestamp: string;
  stats?: {
    malicious: number;
    suspicious: number;
    undetected: number;
    harmless: number;
  };
  details?: string;
  error?: string;
}

/**
 * Scan file buffer for malware using VirusTotal API
 */
export async function scanFile(
  buffer: Buffer,
  filename: string,
  options: {
    timeout?: number;
    skipIfNoApiKey?: boolean;
  } = {}
): Promise<ScanResult> {
  const apiKey = process.env.VIRUSTOTAL_API_KEY;
  
  // If no API key and skipIfNoApiKey is true, pass through
  if (!apiKey) {
    if (options.skipIfNoApiKey) {
      logger.warn('[MalwareScan] No API key configured, skipping scan', {
        filename: filename.substring(0, 50)
      });
      return {
        safe: true,
        scanId: 'skipped_no_api_key',
        timestamp: new Date().toISOString(),
        details: 'Malware scanning not configured'
      };
    } else {
      return {
        safe: false,
        scanId: 'error_no_api_key',
        timestamp: new Date().toISOString(),
        error: 'VirusTotal API key not configured',
        details: 'Set VIRUSTOTAL_API_KEY environment variable'
      };
    }
  }

  const timeout = options.timeout || 30000; // 30 seconds default

  try {
    logger.info('[MalwareScan] Starting scan', {
      filename: filename.substring(0, 50),
      size: buffer.length
    });

    // VirusTotal API v3 - Upload file for scanning
    const formData = new FormData();
    formData.append('file', new Blob([new Uint8Array(buffer)]), filename);

    const uploadPromise = fetch('https://www.virustotal.com/api/v3/files', {
      method: 'POST',
      headers: {
        'x-apikey': apiKey
      },
      body: formData
    });

    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error('VirusTotal scan timed out')), timeout);
    });

    const uploadResponse = await Promise.race([uploadPromise, timeoutPromise]);

    if (!uploadResponse.ok) {
      const errorText = await uploadResponse.text();
      logger.error('[MalwareScan] Upload failed', {
        status: uploadResponse.status,
        error: errorText.substring(0, 200)
      });

      return {
        safe: false,
        scanId: 'error_upload_failed',
        timestamp: new Date().toISOString(),
        error: `VirusTotal upload failed: ${uploadResponse.status}`,
        details: errorText.substring(0, 200)
      };
    }

    const uploadResult = await uploadResponse.json();
    const analysisId = uploadResult.data?.id;

    if (!analysisId) {
      logger.error('[MalwareScan] No analysis ID returned', { uploadResult });
      return {
        safe: false,
        scanId: 'error_no_analysis_id',
        timestamp: new Date().toISOString(),
        error: 'VirusTotal did not return analysis ID'
      };
    }

    // Wait for analysis to complete (usually < 10 seconds)
    let attempts = 0;
    const maxAttempts = 10;
    let analysisResult;

    while (attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds

      const analysisResponse = await fetch(
        `https://www.virustotal.com/api/v3/analyses/${analysisId}`,
        {
          headers: { 'x-apikey': apiKey }
        }
      );

      if (!analysisResponse.ok) {
        logger.warn('[MalwareScan] Analysis check failed', {
          attempt: attempts + 1,
          status: analysisResponse.status
        });
        attempts++;
        continue;
      }

      analysisResult = await analysisResponse.json();

      // Check if analysis is complete
      if (analysisResult.data?.attributes?.status === 'completed') {
        break;
      }

      attempts++;
    }

    if (!analysisResult || analysisResult.data?.attributes?.status !== 'completed') {
      logger.warn('[MalwareScan] Analysis did not complete in time', {
        attempts,
        status: analysisResult?.data?.attributes?.status
      });

      // Fail-safe: Allow file but log warning
      return {
        safe: true,
        scanId: analysisId,
        timestamp: new Date().toISOString(),
        details: 'Analysis timed out - file allowed as fail-open policy'
      };
    }

    // Parse scan results
    const stats = analysisResult.data.attributes.stats;
    const malicious = stats?.malicious || 0;
    const suspicious = stats?.suspicious || 0;

    const safe = malicious === 0 && suspicious === 0;

    logger.info('[MalwareScan] Scan complete', {
      filename: filename.substring(0, 50),
      safe,
      malicious,
      suspicious,
      scanId: analysisId
    });

    return {
      safe,
      scanId: analysisId,
      timestamp: new Date().toISOString(),
      stats: {
        malicious: stats.malicious || 0,
        suspicious: stats.suspicious || 0,
        undetected: stats.undetected || 0,
        harmless: stats.harmless || 0
      },
      details: safe
        ? 'Clean - No threats detected'
        : `Threats detected: ${malicious} malicious, ${suspicious} suspicious`
    };

  } catch (error) {
    logger.error('[MalwareScan] Scan failed', error, {
      filename: filename.substring(0, 50)
    });

    // FAIL-OPEN POLICY: Don't block uploads if scan service is down
    // Log error but allow file (better UX, prevents DoS via VirusTotal outage)
    return {
      safe: true,
      scanId: 'error_scan_failed',
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Unknown error',
      details: 'Scan failed - file allowed as fail-open policy'
    };
  }
}

/**
 * Get cached scan result for known file hash
 * (Future optimization - cache clean files for 24 hours)
 */
export async function getCachedScanResult(
  fileHash: string
): Promise<ScanResult | null> {
  // TODO: Implement scan result caching
  // Store in database: file_scan_cache (hash, result, cached_at)
  // TTL: 24 hours for clean files, never cache malicious
  return null;
}

/**
 * Calculate SHA-256 hash of file buffer
 */
export async function calculateFileHash(buffer: Buffer): Promise<string> {
  const crypto = await import('crypto');
  return crypto.createHash('sha256').update(buffer).digest('hex');
}

/**
 * Check if malware scanning is enabled
 */
export function isMalwareScanningEnabled(): boolean {
  return !!process.env.VIRUSTOTAL_API_KEY;
}

